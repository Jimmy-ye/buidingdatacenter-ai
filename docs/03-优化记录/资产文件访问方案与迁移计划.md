# 资产文件访问方案与迁移计划

**创建时间**：2026-01-23
**问题来源**：移动端图片显示问题 + 未来云存储迁移

---

## 📋 当前问题分析

### 1️⃣ PC 端现状（工作正常但不可持续）

**实现方式**：FastAPI 静态文件挂载

```python
# services/backend/app/main.py
ASSET_WEB_PREFIX = "/local_assets"
BASE_ASSET_DIR = SETTINGS.local_storage_dir
app.add_static_files(ASSET_WEB_PREFIX, BASE_ASSET_DIR)
```

**PC UI 使用方式**：

```python
# Asset 模型中的 URL 生成
@property
def raw_url(self) -> str:
    if self.file_blob and self.file_blob.storage_path:
        return f"{ASSET_WEB_PREFIX}/{self.file_blob.storage_path}"
    return ""
```

**访问路径示例**：
- 前端请求：`http://localhost:8000/local_assets/2025-01/xxx.jpg`
- 后端直接从本地磁盘读取文件返回

**问题**：
- ❌ 只有访问 PC UI 端口的浏览器能看到图片
- ❌ 手机端、第三方客户端无法直接访问
- ❌ 迁移到云存储后，本地路径失效

---

### 2️⃣ 移动端现状（图片不显示）

**移动端期望**：
```dart
// lib/models/asset.dart
rawUrl: json['raw_url']?.toString() ??
        json['download_url']?.toString() ??
        json['file_path']?.toString()
```

**后端当前返回**：
```json
{
  "id": "...",
  "raw_url": "/local_assets/2025-01/xxx.jpg",  // ❌ 移动端无法访问
  "download_url": null  // ❌ 缺少统一下载端点
}
```

**问题根源**：
1. 移动端无法访问 PC 端的本地文件路径
2. 缺少统一的 HTTP 下载端点

---

## 🎯 推荐的长期方案

### 核心原则

> **前端（PC + Mobile）只认一个 HTTP URL，不关心存储细节**

无论后端使用：
- 本地磁盘
- NAS 挂载
- S3/OBS/华为云对象存储
- 独立文件服务

前端只需要：
- 调用统一的下载端点
- 获取图片的 HTTP URL
- 不感知存储位置变化

---

### 方案设计：统一下载端点

#### 1. 后端实现 `/api/v1/assets/{asset_id}/download`

**文件**：`services/backend/app/api/v1/assets.py`

```python
from fastapi import Response
from fastapi.responses import FileResponse
import os

@router.get("/assets/{asset_id}/download")
async def download_asset_file(
    asset_id: str,
    db: Session = Depends(get_db)
):
    """
    统一资产文件下载端点

    功能：
    1. 根据 asset_id 查询 Asset 和 FileBlob
    2. 根据存储类型返回文件：
       - 本地磁盘：FileResponse
       - NAS/对象存储：重定向或代理
    3. 支持 Range 请求（断点续传）
    """
    # 1. 查询资产
    asset = db.query(Asset).filter(Asset.id == asset_id).one_or_none()
    if not asset:
        raise HTTPException(status_code=404, detail="资产不存在")

    # 2. 获取文件信息
    if not asset.file_blob:
        raise HTTPException(status_code=404, detail="文件不存在")

    file_blob = asset.file_blob
    storage_path = file_blob.storage_path
    full_path = os.path.join(settings.local_storage_dir, storage_path)

    # 3. 检查文件是否存在
    if not os.path.exists(full_path):
        raise HTTPException(status_code=404, detail="文件未找到")

    # 4. 返回文件（支持 Range）
    return FileResponse(
        full_path,
        media_type=file_blob.mime_type or 'application/octet-stream',
        filename=file_blob.original_filename or f"asset_{asset_id}"
    )
```

#### 2. Schema 添加 download_url 字段

**文件**：`services/backend/app/schemas/asset.py`

```python
class AssetDetailRead(BaseModel):
    id: uuid.UUID
    title: Optional[str] = None
    modality: Optional[str] = None
    source: Optional[str] = None
    content_role: Optional[str] = None
    capture_time: Optional[datetime] = None
    note: Optional[str] = None

    # ⭐ 添加统一下载 URL
    download_url: Optional[str] = None

    # 兼容字段（逐步废弃）
    raw_url: Optional[str] = None  # 保留用于向后兼容

    # 工程结构关联
    device_id: Optional[uuid.UUID] = None
    system_id: Optional[uuid.UUID] = None
    zone_id: Optional[uuid.UUID] = None
    building_id: Optional[uuid.UUID] = None
```

#### 3. 生成 download_url 的逻辑

**文件**：`services/backend/app/services/asset_service.py`

```python
def build_download_url(asset_id: str, request: Request) -> str:
    """
    生成资产的下载 URL

    返回格式：http://localhost:8000/api/v1/assets/{asset_id}/download
    """
    base_url = str(request.base_url)
    return f"{base_url}/api/v1/assets/{asset_id}/download"
```

**在 API 响应中注入**：

```python
@router.get("/assets/{asset_id}", response_model=AssetDetailRead)
async def get_asset(
    asset_id: str,
    request: Request,
    db: Session = Depends(get_db)
):
    asset = db.query(Asset).filter(Asset.id == asset_id).one_or_none()
    if not asset:
        raise HTTPException(status_code=404, detail="资产不存在")

    # ⭐ 生成下载 URL
    download_url = build_download_url(str(asset.id), request)

    return AssetDetailRead(
        id=asset.id,
        title=asset.title,
        download_url=download_url,  # ⭐ 新字段
        # ... 其他字段
    )
```

---

## 📱 前端适配

### PC 端迁移

**当前代码**（需要修改）：

```python
@property
def raw_url(self) -> str:
    if self.file_blob and self.file_blob.storage_path:
        return f"{ASSET_WEB_PREFIX}/{self.file_blob.storage_path}"
    return ""
```

**迁移后**（使用 download_url）：

```python
@property
def raw_url(self) -> str:
    # ⭐ 优先使用 download_url
    if hasattr(self, 'download_url') and self.download_url:
        return self.download_url

    # 兼容旧逻辑（临时）
    if self.file_blob and self.file_blob.storage_path:
        return f"{ASSET_WEB_PREFIX}/{self.file_blob.storage_path}"
    return ""
```

### 移动端适配

**当前代码**（已兼容多种字段）：

```dart
// lib/models/asset.dart
rawUrl: json['raw_url']?.toString() ??
        json['download_url']?.toString() ??
        json['file_path']?.toString()
```

**未来优化**（优先使用 download_url）：

```dart
rawUrl: json['download_url']?.toString() ??  // ⭐ 统一下载端点
        json['raw_url']?.toString() ??        // 兼容 PC 端旧字段
        json['file_path']?.toString()        // 兼容原始路径
```

---

## 🚀 迁移到云存储的步骤

### 第 1 步：实现统一下载端点（立即执行）

**优先级**：P0

**文件**：
- `services/backend/app/api/v1/assets.py` - 添加 `/assets/{asset_id}/download`
- `services/backend/app/schemas/asset.py` - 添加 `download_url` 字段

### 第 2 步：PC 端迁移到 download_url

**优先级**：P1

**文件**：
- `desktop/nicegui_app/events/asset_events.py` - 修改 URL 生成逻辑
- `services/backend/app/services/asset_service.py` - 注入 download_url

### 第 3 步：云存储集成（可选）

**优先级**：P2

**支持方案**：
- **方案 A**：NAS 挂载到后端机器
  - 后端从 NAS 路径读取文件
  - 下载端点保持不变

- **方案 B**：S3/OBS 对象存储
  - 后端生成签名 URL
  - 下载端点返回 302 重定向

- **方案 C**：独立文件服务
  - 后端代理请求到文件服务
  - 统一认证和权限控制

---

## ✅ 验收标准

### P0：统一下载端点
- [ ] 后端实现 `/api/v1/assets/{asset_id}/download`
- [ ] 支持 Range 请求（断点续传）
- [ ] 正确处理 404 错误
- [ ] 返回正确的 MIME 类型

### P1：Schema 更新
- [ ] `AssetDetailRead` 添加 `download_url` 字段
- [ ] 所有资产列表接口返回 `download_url`
- [ ] PC 端迁移到使用 `download_url`

### P2：移动端显示
- [ ] 移动端图片正常显示
- [ ] 支持大图查看
- [ ] 支持图片缓存

---

## 📝 技术要点

### URL 优先级（前端）

```python
# 1. 统一下载端点（最推荐）
download_url = "http://localhost:8000/api/v1/assets/{id}/download"

# 2. PC 端本地路径（仅用于向后兼容）
raw_url = "/local_assets/2025-01/xxx.jpg"

# 3. 原始文件路径（调试用）
file_path = "/var/lib/bdc-ai/assets/xxx.jpg"
```

### 移动端图片缓存

```dart
// 使用 cached_network_image 自动缓存
CachedNetworkImage(
  imageUrl: asset.downloadUrl,
  placeholder: (context, url) => CircularProgressIndicator(),
  errorWidget: (context, url, error) => Icon(Icons.error),
)
```

### CORS 配置

确保下载端点支持跨域：

```python
# main.py
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

---

## 🎯 优势总结

### 前端优势
- ✅ 不关心存储位置（本地/NAS/云）
- ✅ 统一的访问方式（HTTP URL）
- ✅ 代码改动最小

### 后端优势
- ✅ 存储迁移对前端透明
- ✅ 统一的权限控制
- ✅ 便于实现 CDN 加速

### 运维优势
- ✅ 灵活的存储方案选择
- ✅ 便于实现负载均衡
- ✅ 支持多云/混合云策略

---

**创建者**：Claude Code
**最后更新**：2026-01-23
**参考文档**：`docs/02-技术文档/工程结构API设计.md`
