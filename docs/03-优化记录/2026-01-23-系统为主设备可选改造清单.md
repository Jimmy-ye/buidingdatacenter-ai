# 系统为主、设备可选资产挂载改造清单（V1）

> 目标：在不推翻现有工程结构（Project → Building → System → Device）的前提下，让资产 `Asset` 以 **System 为主挂点，Device 为可选细化层级，Zone 表示位置**，并在 PC 端支持“系统视角上传与浏览”。

---

## 1. 总体方案

- **结构层不动**：继续沿用 `Project / Building / System / Device (+ Zone)` 模型。
- **资产挂载改造**：
  - `system_id`：主外键，大部分资产只挂系统即可；
  - `device_id`：可选，仅在需要针对大设备细分时使用；
  - `zone_id`：可选，用于位置视角（楼层/区域）。
- **UI 行为调整**：
  - 选中 System 节点即可直接“看资产 / 传资产”；
  - 选中 Device 节点，则视为系统内的一个精细视图。

---

## 2. 后端改动点

### 2.1 数据模型与迁移

1. **ORM 与字段**
   - 确认 `Asset` 模型包含：`project_id, building_id, zone_id, system_id, device_id`。
   - 语义约定：
     - `system_id`: 作为主归属字段（新资产应尽量必填）；
     - `device_id`: 可空，表示“系统里的哪个设备”；
     - `zone_id`: 可空，表示“在哪个区域”。

2. **数据库迁移（assets 表）**
   - 若缺少 `system_id` 字段：
     - `ALTER TABLE assets ADD COLUMN IF NOT EXISTS system_id uuid NULL;`
     - `CREATE INDEX IF NOT EXISTS idx_assets_system_id ON assets(system_id);`
   - 从 `device_id` 回填 `system_id`：
     - 通过 `devices.system_id` 反查并更新历史记录。

3. **Pydantic Schema**
   - `AssetCreate / AssetUpdate / AssetRead`：
     - `system_id: UUID` 作为推荐必填；
     - `device_id: UUID | None`；
     - `zone_id: UUID | None`。

### 2.2 上传接口（以 System 为主）

以 `POST /assets/upload_image_with_note` 为例：

1. **请求参数支持**：
   - `project_id`（必填）；
   - `system_id`（推荐必填）；
   - `device_id`（可选）；
   - `zone_id`（可选）；
   - 仍兼容只传 `device_id` 的旧用法。

2. **工程层级解析逻辑**（示意）：
   - 只给 `device_id`：
     - 查询 Device → 补齐 `system_id / building_id / zone_id`；
   - 给 `system_id + zone_id`：
     - 校验二者属于同一 Building，仅写入系统+区域；
   - 给 `system_id + device_id`：
     - 校验 device.system_id == system_id；
   - 统一生成 `engineer_path = Building / System[/Device]`。

### 2.3 查询与反向索引

1. **统一 `/assets` 过滤**：
   - 新增/强化参数：`system_id`, `zone_id`, `device_id`；
   - 语义：
     - `system_id=...` → 该系统下所有资产（不区分设备）；
     - `system_id + device_id` → 系统内某设备资产；
     - `zone_id=...` → 区域视角资产。

2. **工程节点 → 资产接口（薄封装）**：
   - `GET /devices/{device_id}/assets` → 内部转 `/assets?device_id=...`；
   - `GET /systems/{system_id}/assets` → `/assets?system_id=...`；
   - `GET /zones/{zone_id}/assets` → `/assets?zone_id=...`；
   - `GET /buildings/{building_id}/assets` → `/assets?building_id=...`。

---

## 3. PC UI（NiceGUI）改动点

### 3.1 工程树选择逻辑

1. **状态变量**：
   - `current_tree_node_type`：`building/system/device/...`；
   - `current_tree_node_id`：对应的原始 UUID；
   - `current_device_id`：保留给“设备视角”使用。

2. **选中节点时的行为**：
   - 选中 `system`：
     - 记录 `current_tree_node_type = "system"`；
     - 清空 `current_device_id`；
     - 调用新的 `list_assets(system_id=...)`，填充资产表格；
   - 选中 `device`：
     - 记录 `current_tree_node_type = "device"`、`current_device_id = ...`；
     - 调用现有 `list_assets_for_device(device_id)`；
   - 其他类型（building/zone）暂不加载资产，或后续按需扩展。

### 3.2 上传按钮行为

1. **可用性控制**：
   - 当选中节点类型为 `system` 或 `device` 时启用“上传图片资产”按钮；
   - 其他情况禁用并提示“请先在左侧选择系统或设备”。

2. **上传对话框参数**：
   - 选中系统：
     - 传入 `project_id + system_id`，`device_id=None`；
   - 选中设备：
     - 传入 `project_id + device_id`（后端由设备推导系统），或显式同时带上 `system_id + device_id`；
   - 其余逻辑（文件选择、自动路由 OCR/LLM）保持不变。

3. **上传完成后的刷新**：
   - 回调中将新资产 `append` 到当前列表，并调用统一的 `apply_asset_filters()` 刷新表格。

---

## 4. 实施顺序与工作量评估

### 4.1 推荐实施顺序

1. **后端 schema + 迁移（~0.5 天）**
   - 增加/确认 `assets.system_id`；
   - 回填历史数据；
   - 更新 Pydantic Schema。

2. **上传接口与 `/assets` 查询扩展（~1 天）**
   - 完善工程层级解析逻辑；
   - 补齐 `system_id / zone_id / device_id` 过滤。

3. **工程节点 → 资产反向接口（~0.5 天）**
   - 以 `/assets` 为核心做薄封装；
   - 编写/更新集成测试脚本做回归。

4. **PC UI 行为调整（~1 天）**
   - 树节点选择逻辑支持系统视角；
   - 上传按钮逻辑按系统/设备分支；
   - 简单文案提示“系统为主，设备为细化视图”。

### 4.2 总体工作量

- 后端：约 2~2.5 天；
- PC UI：约 1 天；
- 预留联调与测试：0.5~1 天；
- 合计：**约 3~3.5 天即可完成 V1 改造**。

---

## 5. 详细实施步骤（建议按顺序执行）

### 5.1 后端：数据模型与迁移

1. **确认当前字段**
   - 打开 `shared/db/models_asset.py`（或等价模型文件），确认 `Asset` 是否已有：
     - `project_id, building_id, zone_id, system_id, device_id, engineer_path`。
   - 若缺少 `system_id`：先在 ORM 模型中添加，再补数据库迁移。

2. **编写迁移 SQL / 脚本**
   - 添加字段：
     - `ALTER TABLE assets ADD COLUMN IF NOT EXISTS system_id uuid NULL;`
     - `CREATE INDEX IF NOT EXISTS idx_assets_system_id ON assets(system_id);`
   - 从 `device_id` 回填 `system_id`：
     - 通过 `devices` 表查询 `device.system_id`，更新到 `assets.system_id`；
     - 注意使用 `WHERE assets.system_id IS NULL` 避免覆盖已有数据。

3. **本地验证迁移**
   - 在开发库执行迁移脚本；
   - 随机抽查几条资产，确认：
     - `device_id` 不为空的资产已经有对应 `system_id`；
     - 没有设备的资产字段不被误填。

4. **更新 Pydantic schema 与依赖代码**
   - 更新 `AssetCreate / AssetUpdate / AssetRead`：
     - 增加/确认 `system_id` 字段；
     - 标明 `device_id / zone_id` 可选；
   - 搜索所有使用 `AssetCreate` 的地方（尤其是上传接口），检查是否需要补传 `system_id`。

### 5.2 后端：上传接口改造

1. **统一工程层级解析函数**
   - 建议集中在一个服务函数，如 `_resolve_engineering_hierarchy(...)`：
     - 入参支持 `project_id, building_id, system_id, device_id, zone_id`（部分可空）；
     - 内部按优先级推导：
       - 若给了 `device_id`，先查设备，再反推 `system_id / building_id / zone_id`；
       - 若只给 `system_id`，从系统反推 `building_id`；
       - 若同时给 `system_id + device_id`，做一致性校验。

2. **在上传接口中复用解析逻辑**
   - 在 `upload_image_with_note` 中：
     - 从 Query/Form 中取出工程相关参数；
     - 调用 `_resolve_engineering_hierarchy` 得到标准化的 `building_id/system_id/device_id/zone_id/engineer_path`；
     - 创建 `Asset` 实体时统一使用该结果。

3. **兼容旧调用方式**
   - 若老代码只传 `project_id + device_id`：
     - 仍能从设备反推系统，不强制前端立刻改；
   - 后续逐步将 PC UI / 脚本改为显式传 `system_id`，减少推导链路。

### 5.3 后端：查询与反向索引实现

1. **扩展 `/assets`**
   - 在查询函数中增加可选过滤：
     - `if system_id: query = query.filter(Asset.system_id == system_id)`；
     - `if device_id: query = query.filter(Asset.device_id == device_id)`；
     - `if zone_id: query = query.filter(Asset.zone_id == zone_id)`；
   - 注意与 `project_id/building_id` 组合使用时不要互相覆盖。

2. **实现工程节点 → 资产接口**
   - 每个接口尽量只做参数转发，逻辑都走 `/assets`：
     - `GET /systems/{id}/assets`：内部调用 `/assets?system_id=...`；
     - `GET /devices/{id}/assets`：内部调用 `/assets?device_id=...`；
   - 好处：后续过滤字段统一收敛在一个地方易维护。

3. **写简单的集成测试/脚本**
   - 用 `requests` 或你现有的 `tests/integration` 脚本：
     - 创建项目 → building/system/device → 上传几张图片；
     - 分别调用 `systems/{id}/assets` 与 `devices/{id}/assets`，核对数量与工程路径是否正确。

### 5.4 PC UI：工程树与资产加载

1. **增加 system 视角加载函数（可选）**
   - 当前已有 `list_assets_for_device(device_id)`；
   - 可以新增 `list_assets_for_system(system_id)`，实际调用 `/assets?system_id=...`。

2. **调整 `on_select_tree` 行为**
   - 现状：只有 `node_type == "device"` 时才加载资产；
   - 改造方案：
     - 选中 `system`：清空 `current_device_id`，加载系统级资产；
     - 选中 `device`：保留现有行为；
     - 选中 `building/zone`：清空资产列表（或后续扩展）。

3. **调试建议**
   - 在 `on_select_tree` 中临时打印：`node_type/raw_id` 和返回的资产数量；
   - 确认系统节点点击时确实触发了正确的 API 调用。

### 5.5 PC UI：上传与详情联动

1. **上传**
   - 在 `on_upload_asset_click` 中：
     - 根据 `current_tree_node_type` 判断当前上下文（system or device）；
     - 选中 system 时只传 `system_id`；
     - 选中 device 时传 `device_id`，系统由后端推导或同时传递。

2. **上传成功后的刷新策略**
   - 不必重新加载整棵树，只需：
     - `enrich_asset(new_asset)`；
     - append 到 `all_assets_for_device` 或系统资产列表；
     - 调用 `apply_asset_filters()` 重新渲染 table。

3. **资产详情/预览的状态同步**
   - 当前已通过 `AssetStateRef + sync_and_update_asset_detail()` 解决“首次点击显示旧资产”的问题；
   - 后续如再新增状态（例如多选），优先挂在 `AssetStateRef` 下集中管理。

---

## 6. 注意事项与常见坑

### 6.1 兼容已有数据与调用方

- 迁移前先评估：是否存在大量无 `device_id` 的历史资产？
  - 若有，需要专门脚本/规则补充 `system_id`，否则系统视角查询会漏数据；
- 上传接口要保持向后兼容：
  - 不要突然把 `system_id` 变为强制参数，先通过推导兼容旧前端；
- `/assets` 查询新增过滤字段时：
  - 确认旧的 Web/脚本调用不会因参数名冲突而行为改变。

### 6.2 工程层级一致性

- 校验规则必须严格：
  - 同时给 `system_id + device_id` 时，要求 `device.system_id == system_id`；
  - 同时给 `system_id + zone_id` 时，要求同属一个 `building_id`；
- 避免出现“系统在 A 楼、设备在 B 楼”的脏数据，一旦出现会导致树/统计混乱。

### 6.3 性能与索引

- 在 `assets.system_id` 上建索引是必要的，否则系统级查询会退化为全表扫描；
- 若后续按 `zone_id` 查询很多，也建议给 `zone_id` 加索引；
- 反向接口全部复用 `/assets`，可以通过在该查询中统一做分页/排序，避免在多个地方实现复杂逻辑。

### 6.4 UI 交互体验

- 系统节点下没有任何资产时，建议在右侧显示友好提示：
  - 如“此系统下暂无资产，建议先上传系统总览照片或能耗表格”；
- 对于设备节点：
  - 如果系统下资产很多，而设备下为空，提示“该设备暂无专属资产，可切换到系统级查看整体资料”。

### 6.5 回滚与灰度

- 代码层面：
  - 避免删除旧接口，先标记为 deprecated；
  - 新老逻辑通过参数（是否传 system_id）自然区分；
- 数据层面：
  - 增加字段和索引是单向操作，回滚成本高；
  - 若有疑虑，可在测试库完整演练一轮迁移 + 回滚（备份/恢复）。

---

## 7. 后续可以考虑的增强点

- 按系统维度做资产统计视图：每个系统下图片/表格/诊断报告数量；
- 在 PC UI 的系统节点右侧增加一个“资产摘要角标”（如：`📷 12 / 📊 3`）；
- 支持按 `content_role` 在系统级快速筛选，如“只看现场问题图片”；
- 在将来接入移动端时，直接以 `system_id` 为主，将端侧上传路径与本次改造保持一致。

