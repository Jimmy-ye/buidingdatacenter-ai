# 工程结构树与扁平设备视图测试说明

本文档总结当前工程结构相关实现情况，并说明如何使用集成测试脚本验证：

- Project 管理（含软删除、硬删除、恢复功能）
- Project Tags 扩展
- Building / Zone / System / Device 工程结构 API
- JSON `tags` 字段（Project/Building/Zone/System/Device）
- Project 级扁平设备查询
- 工程结构树（structure_tree）

---

## 1. 已实现功能小结

### 1.1 Project 数据模型与软删除（`shared/db/models_project.py`）

#### 1.1.1 Project 基础字段

- `id`: UUID (主键)
- `name`: String(200) - 项目名称
- `client`: String(200) - 客户名称
- `location`: String(200) - 项目位置
- `type`: String(50) - 项目类型
- `status`: String(50) - 项目状态
- `start_date`: Date - 开始日期
- `end_date`: Date - 结束日期
- `tags`: JSONB - 扩展标签（支持任意 JSON 结构）

#### 1.1.2 Project 软删除字段

- `is_deleted`: Boolean - 是否已删除（默认 `False`，有索引）
- `deleted_at`: DateTime - 删除时间
- `deleted_by`: String(100) - 删除操作人
- `deletion_reason`: String(500) - 删除原因

#### 1.1.3 Project 关联关系

- `buildings`: relationship - 项目的所有建筑（级联删除）

### 1.2 Project API 端点（`services/backend/app/api/v1/projects.py`）

#### 1.2.1 基础 CRUD

- `GET /api/v1/projects/`
  - Query 参数：
    - `skip: int = 0` - 分页偏移
    - `limit: int = 100` - 分页大小
    - `include_deleted: bool = False` - 是否包含已删除项目
- `POST /api/v1/projects/` - 创建新项目
- `GET /api/v1/projects/{project_id}` - 获取单个项目详情
  - Query 参数：`include_deleted: bool = False`
- `PATCH /api/v1/projects/{project_id}` - 更新项目信息

#### 1.2.2 删除与恢复

- `DELETE /api/v1/projects/{project_id}` - 删除项目
  - Query 参数：
    - `reason: str | None` - 删除原因
    - `hard_delete: bool = False` - 是否物理删除（危险操作）
  - Header：
    - `operator: str | None` - 操作人
  - 行为：
    - **软删除**（默认）：设置 `is_deleted=True`，记录删除信息
    - **硬删除**（`hard_delete=true`）：先级联删除所有关联的 assets，再物理删除项目记录

- `POST /api/v1/projects/{project_id}/restore` - 恢复已软删除的项目
  - Header：
    - `operator: str | None` - 操作人
  - 行为：重置 `is_deleted=False`，清空删除信息

> **重要**：硬删除会级联删除 `assets` 表中所有 `project_id` 匹配的记录，此操作不可逆！

### 1.3 数据模型（`shared/db/models_project.py`）

在 Project 和其他四个工程实体模型中都增加了 `tags` JSONB 字段：

- `Project`
  - `tags: JSONB | None`
- `Building`
  - `tags: JSONB | None`
- `Zone`
  - `tags: JSONB | None`
- `BuildingSystem`
  - `tags: JSONB | None`
- `Device`
  - `tags: JSONB | None`

> 注意：这是 ORM 定义的更新，PostgreSQL 表本身需要执行迁移脚本添加 `tags` 列。

### 1.4 工程结构 API（`services/backend/app/api/v1/engineering.py`）

主要端点：

- Building
  - `GET  /api/v1/projects/{project_id}/buildings`
  - `POST /api/v1/projects/{project_id}/buildings`
  - `GET  /api/v1/buildings/{building_id}` / `PATCH` / `DELETE`
- Zone（与 System 同级，位置视图）
  - `GET  /api/v1/buildings/{building_id}/zones`
  - `POST /api/v1/buildings/{building_id}/zones`
  - `GET  /api/v1/zones/{zone_id}` / `PATCH` / `DELETE`
  - `GET  /api/v1/zones/{zone_id}/devices`（只读视图）
- System（Device 主归属）
  - `GET  /api/v1/buildings/{building_id}/systems`
  - `POST /api/v1/buildings/{building_id}/systems`
  - `GET  /api/v1/systems/{system_id}` / `PATCH` / `DELETE`
  - `GET  /api/v1/systems/{system_id}/devices`
  - `POST /api/v1/systems/{system_id}/devices`（创建设备的唯一入口）
- Device
  - `GET  /api/v1/devices/{device_id}` / `PATCH` / `DELETE`

### 1.5 扁平设备查询（Flat View）

- `GET /api/v1/projects/{project_id}/devices/flat`

支持的过滤参数：

- `system_id: uuid | None`
- `zone_id: uuid | None`
- `device_type: str | None`
- `min_rated_power: float | None`
- `tags: str | None`（逗号分隔，AND 语义，通过 `Device.tags.contains([...])` 实现）
- `search: str | None`（在 `model` / `serial_no` 上模糊搜索）

返回模型：`DeviceFlatRead`，包含：

- 设备基本信息：`id, system_id, zone_id, device_type, model, rated_power, serial_no, tags`
- `primary_system { id, name, type }` 作为主归属信息
- `location { id, name }` 作为位置信息
- `engineer_path`：`Building / System / Device` 字符串

### 1.6 工程结构树（Structure Tree）

Service 文件：`services/backend/app/services/tree_service.py`

端点：

- `GET /api/v1/projects/{project_id}/structure_tree`

返回结构示例：

```jsonc
{
  "project_id": "...",
  "tree": {
    "id": "project-root",
    "name": "项目根",
    "type": "project_root",
    "children": [
      {
        "id": "building-...",
        "name": "A座办公楼",
        "type": "building",
        "children": [
          {
            "id": "system-...",
            "name": "HVAC系统",
            "type": "system",
            "children": [
              {
                "id": "device-...",
                "name": "风机盘管FCU-03",
                "type": "device",
                "device_type": "fcu",
                "zone": { "id": "zone-...", "name": "5F办公区" }
              }
            ]
          }
        ],
        "zones": [
          {
            "id": "zone-...",
            "name": "5F办公区",
            "type": "zone",
            "device_count": 1
          }
        ]
      }
    ]
  }
}
```

实现基于 `bigtree`：

- `build_project_tree(project_id, db)`: 查询 Building/Zone/System/Device 并构建 bigtree Node
- `tree_to_dict(node)`: 将 Node 递归转换为字典

---

## 2. 集成测试脚本说明

测试脚本路径（可选，需要你按照示例自行创建）：

- `tests/integration/test_engineering_structure.py`

脚本逻辑步骤：

1. **创建 Project**
   - `POST /api/v1/projects/`
   - 打印状态码与响应内容，获取 `project_id`
2. **创建 Building / Zone / System / Device**
   - `POST /api/v1/projects/{project_id}/buildings`
     - 建筑名称：`A座办公楼`
     - `tags`: `["总部园区"]`
   - `POST /api/v1/buildings/{building_id}/zones`
     - 区域名称：`5F办公区`
     - `tags`: `["5F"]`
   - `POST /api/v1/buildings/{building_id}/systems`
     - 系统类型：`HVAC`
     - 名称：`HVAC系统`
     - `tags`: `["空调"]`
   - `POST /api/v1/systems/{system_id}/devices`
     - `zone_id`：上一步 Zone 的 ID
     - `device_type`: `fcu`
     - `model`: `风机盘管FCU-03`
     - `tags`: `["高能耗", "待观察"]`
3. **测试扁平设备查询**
   - `GET /api/v1/projects/{project_id}/devices/flat`
   - Query 示例：
     - `device_type=fcu`
     - `min_rated_power=1.0`
     - `tags=高能耗`
   - 打印状态码与 JSON 内容（包含 `primary_system` / `location` / `engineer_path`）
4. **测试工程结构树**
   - `GET /api/v1/projects/{project_id}/structure_tree`
   - 打印状态码与响应文本的前 800 个字符，用于快速查看树结构是否符合预期。

运行脚本入口（示例）：

```python
if __name__ == "__main__":
    main()
```

---

## 3. 手动测试步骤

### 3.1 安装后端依赖

在项目根目录运行：

```bash
pip install -r services/backend/requirements.txt
```

确保包含：

- `fastapi`
- `sqlalchemy`
- `psycopg2-binary`
- `PaddleOCR`
- `bigtree==0.16.4`

### 3.2 更新数据库 Schema（**必须执行**）

> ⚠ **重要：ORM 模型已包含 `tags` 和软删除字段，但 PostgreSQL 表需要手动添加列，否则所有创建/更新操作都会报 `500 Internal Server Error`。**
>
> 原因：`Base.metadata.create_all()` 不会自动修改已存在的表结构。

请确认你连接的是实际运行后端时使用的 PostgreSQL 数据库（即 `BDC_DATABASE_URL` 指向的数据库），然后按以下步骤执行迁移：

#### 3.2.1 Project 表迁移（软删除字段 + tags）

**方式 1：使用提供的迁移脚本**

```bash
# 执行软删除字段迁移
psql -h localhost -p 5432 -U admin -d bdc_ai -f migrations/add_soft_delete_fields.sql

# 执行 tags 字段迁移
python migrations/add_tags_field.py
```

**方式 2：手动执行 SQL**

```sql
-- 添加软删除字段
ALTER TABLE projects ADD COLUMN IF NOT EXISTS is_deleted BOOLEAN NOT NULL DEFAULT FALSE;
ALTER TABLE projects ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMP;
ALTER TABLE projects ADD COLUMN IF NOT EXISTS deleted_by VARCHAR(100);
ALTER TABLE projects ADD COLUMN IF NOT EXISTS deletion_reason VARCHAR(500);
CREATE INDEX IF NOT EXISTS idx_projects_is_deleted ON projects(is_deleted);

-- 添加 tags 字段
ALTER TABLE projects ADD COLUMN IF NOT EXISTS tags JSONB;
```

#### 3.2.2 工程结构表迁移（tags 字段）

为以下表添加 `tags` JSONB 列：

```sql
ALTER TABLE buildings ADD COLUMN IF NOT EXISTS tags jsonb;
ALTER TABLE zones     ADD COLUMN IF NOT EXISTS tags jsonb;
ALTER TABLE systems   ADD COLUMN IF NOT EXISTS tags jsonb;
ALTER TABLE devices   ADD COLUMN IF NOT EXISTS tags jsonb;
```

> 注意：`systems` 是 ORM 中 `BuildingSystem.__tablename__ = "systems"` 对应的真实表名，**不是** `building_systems`。

#### 3.2.3 验证迁移

执行完成后，可以用以下 SQL 检查列是否存在：

```sql
-- 检查 Project 表的软删除字段
SELECT column_name, data_type
FROM information_schema.columns
WHERE table_name = 'projects' AND column_name IN ('is_deleted', 'deleted_at', 'deleted_by', 'deletion_reason', 'tags');

-- 检查 buildings 表的 tags 列
SELECT column_name, data_type
FROM information_schema.columns
WHERE table_name = 'buildings' AND column_name = 'tags';
```

#### 3.2.4 重建数据库（替代方案）

开发环境中如果允许清空数据，也可以采用"重建库"的方式：

1. 删除原来的 `bdc_ai` 数据库
2. 重新创建空数据库
3. 启动后端，由 `Base.metadata.create_all` 自动建表（会包含所有新字段）

### 3.3 启动后端服务

在项目根目录执行：

```bash
python -m uvicorn services.backend.app.main:app --reload
```

确认浏览器访问：`http://127.0.0.1:8000/docs` 可以看到 `engineering` 相关 API。

### 3.4 运行工程结构集成测试

在项目根目录执行：

```bash
python tests/integration/test_engineering_structure.py
```

预期输出包括：

- Project / Building / Zone / System / Device 创建的状态码与响应内容
- `/api/v1/projects/{project_id}/devices/flat` 的 JSON 列表（包含主系统、位置、工程路径）
- `/api/v1/projects/{project_id}/structure_tree` 的 JSON 片段（树结构）

如需通过 pytest 统一运行集成测试（在你创建好上述脚本之后）：

```bash
pytest tests/integration/test_engineering_structure.py -v
```

### 2.1 默认系统模板测试（可选）

如果后端启用了“新建 Building 后自动生成基础系统”的功能，建议在集成测试脚本中增加以下校验步骤：

1. 在步骤 2 中调用 `POST /api/v1/projects/{project_id}/buildings` 创建 Building 后，记录返回的 `building_id`。
2. 调用：

   ```bash
   GET /api/v1/buildings/{building_id}/systems
   ```

3. 预期结果：

   - 响应状态码为 `200 OK`。
   - 返回的系统列表中至少包含以下若干系统（名称/类型可根据实际实现微调）：
     - 围护结构（`type="envelope"`）
     - 制冷（`type="cooling"`）
     - 制热（`type="heating"`）
     - 空调末端（`type="terminal_hvac"`）
     - 照明（`type="lighting"`）
     - 电梯（`type="elevator"`）
     - 动力（`type="power"`）
     - 电力监控（`type="ems"`）
     - 能管平台（`type="energy_platform"`）

4. 如需后续扩展，可以在同一测试中继续通过 `POST /api/v1/systems/{system_id}/devices` 为其中一个系统增补设备，并验证扁平设备查询与 `structure_tree` 中的结构是否与预期一致。

> 提示：如果当前环境尚未实现自动系统创建功能，可以先保持这部分测试为“跳过/预留”，待功能落地后再启用。

---

## 4. Project 软删除与硬删除测试

### 4.1 测试目标

验证 Project 的删除策略符合以下要求：

1. **软删除（默认）**
   - DELETE 不带 `hard_delete` 参数时，设置 `is_deleted=True`
   - GET /projects/ 默认不显示已删除项目
   - GET /projects/?include_deleted=true 显示已删除项目
   - 可通过 POST /projects/{id}/restore 恢复

2. **硬删除**
   - DELETE 带 `hard_delete=true` 时，物理删除项目记录
   - 同时级联删除 assets 表中所有相关记录
   - 必须提供 `reason` 参数

### 4.2 手动测试步骤

#### 步骤 1：创建测试项目

```bash
curl -X POST "http://localhost:8000/api/v1/projects/" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "删除测试项目",
    "client": "测试客户",
    "location": "测试位置",
    "type": "商业综合体",
    "status": "设计中",
    "tags": {
      "building_type": "商业",
      "area": 50000,
      "energy_tech": ["HVAC", "照明"]
    }
  }'
```

保存返回的 `id` 为 `{project_id}`。

#### 步骤 2：测试软删除

```bash
curl -X DELETE "http://localhost:8000/api/v1/projects/{project_id}?reason=测试软删除" \
  -H "operator:测试用户"
```

预期返回：`204 No Content`

#### 步骤 3：验证软删除结果

```bash
# 应该返回空列表
curl "http://localhost:8000/api/v1/projects/"

# 应该返回已删除的项目
curl "http://localhost:8000/api/v1/projects/?include_deleted=true"
```

验证：
- 第一个请求返回 `[]`
- 第二个请求返回项目，`is_deleted=true`，包含 `deleted_at`、`deleted_by`、`deletion_reason`

#### 步骤 4：恢复项目

```bash
curl -X POST "http://localhost:8000/api/v1/projects/{project_id}/restore" \
  -H "operator:测试用户"
```

预期返回：`200 OK`，项目 `is_deleted=false`，删除信息字段为 `null`。

#### 步骤 5：再次软删除（为硬删除测试做准备）

```bash
curl -X DELETE "http://localhost:8000/api/v1/projects/{project_id}?reason=准备硬删除" \
  -H "operator:测试用户"
```

#### 步骤 6：测试硬删除（⚠ 危险操作）

```bash
curl -X DELETE "http://localhost:8000/api/v1/projects/{project_id}?hard_delete=true&reason=测试硬删除" \
  -H "operator:测试用户"
```

预期返回：`204 No Content`

#### 步骤 7：验证硬删除结果

```bash
# 项目应该不存在
curl -w "%{http_code}" "http://localhost:8000/api/v1/projects/{project_id}"

# 应该返回 404
```

在 PostgreSQL 中验证：

```sql
-- 项目记录应该不存在
SELECT * FROM projects WHERE id = '{project_id}';
-- 返回：0 rows

-- 相关 assets 也应该被删除
SELECT * FROM assets WHERE project_id = '{project_id}';
-- 返回：0 rows
```

### 4.3 自动化测试脚本示例

以下是一个完整的测试脚本示例（需要后端服务已启动）：

```python
import requests
import time

BASE_URL = "http://localhost:8000/api/v1"

def test_delete_strategy():
    # 1. 创建项目
    response = requests.post(f"{BASE_URL}/projects/", json={
        "name": "删除测试项目",
        "client": "测试客户",
        "tags": {"test": True}
    })
    assert response.status_code == 201
    project_id = response.json()["id"]
    print(f"✓ 创建项目: {project_id}")

    # 2. 软删除
    response = requests.delete(
        f"{BASE_URL}/projects/{project_id}",
        params={"reason": "测试软删除"},
        headers={"operator": "测试用户"}
    )
    assert response.status_code == 204
    print("✓ 软删除成功")

    # 3. 验证默认查询不包含已删除项目
    response = requests.get(f"{BASE_URL}/projects/")
    assert response.status_code == 200
    assert len([p for p in response.json() if p["id"] == project_id]) == 0
    print("✓ 默认查询不显示已删除项目")

    # 4. 验证 include_deleted=true 显示已删除项目
    response = requests.get(f"{BASE_URL}/projects/?include_deleted=true")
    assert response.status_code == 200
    deleted_project = [p for p in response.json() if p["id"] == project_id][0]
    assert deleted_project["is_deleted"] == True
    assert deleted_project["deleted_by"] == "测试用户"
    print("✓ include_deleted=true 显示已删除项目")

    # 5. 恢复项目
    response = requests.post(
        f"{BASE_URL}/projects/{project_id}/restore",
        headers={"operator": "测试用户"}
    )
    assert response.status_code == 200
    assert response.json()["is_deleted"] == False
    print("✓ 恢复项目成功")

    # 6. 再次软删除
    response = requests.delete(
        f"{BASE_URL}/projects/{project_id}",
        params={"reason": "准备硬删除"}
    )
    assert response.status_code == 204
    print("✓ 再次软删除")

    # 7. 硬删除（⚠ 危险操作）
    response = requests.delete(
        f"{BASE_URL}/projects/{project_id}",
        params={"hard_delete": True, "reason": "测试硬删除"},
        headers={"operator": "测试用户"}
    )
    assert response.status_code == 204
    print("✓ 硬删除成功")

    # 8. 验证项目已不存在
    response = requests.get(f"{BASE_URL}/projects/{project_id}")
    assert response.status_code == 404
    print("✓ 项目已完全删除")

    print("\n所有测试通过！✅")

if __name__ == "__main__":
    test_delete_strategy()
```

---

## 5. 后续扩展建议

在当前实现基础上，可以进一步增加：

- 设备与资产（Asset）的反向索引 API：
  - `/devices/{device_id}/assets`
  - `/systems/{system_id}/assets`
  - `/zones/{zone_id}/assets`
  - `/buildings/{building_id}/assets`
- 资产统计摘要接口：`/devices/{device_id}/assets/summary`
- 更多标签查询能力（如 `tags_any` 的 OR 语义）

本测试文档可作为后续工程结构相关变更和回归测试的基准。
